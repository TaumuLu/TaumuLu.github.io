---
title: JS积累
date: 2017-03-14 23:55:28
tags: Collect
---

## 前言
在此记录自己平时学习知识点时自己恍然大悟的理解及体会，不一定准确理解，但定是当时最棒的理解了

## 日常积累
- Scope
    共享的Scope，所以循环中创建多个函数会只取得最后一次循环变量的赋值

- 鼠标事件
    js鼠标拖拽要触发mousemove事件绑定在document元素上，可解决快速移动失效所拖拽元素跟不上的问题，其他类似问题都可绑定在document上解决

- 表达式赋值
    (operation)()赋值运算再执行函数的关键在于赋值时取到的函数为执行时直接触发的函数，而不在于会把这个函数赋值给谁再由它来执行(决定this指向)

- 作用域
    查找变量先从作用域的前端开始，即当前环境的变量对象或活动对象查，之后若在函数中再沿着Scope中保存的父变量对象的层级链向上查找至全局对象，浏览器中即window对象，之后再进行二维作用域链查找，因window继承于Object.prototype对象，所以查到Object.prototype为止

- 函数参数解构赋值
    解构赋值function({x=1,y=2}={})，{}为默认值，即没有传入参数将{}对象做为默认值，因为默认值为空对象，所以又触发设置默认的对象解构赋值所以参数为1，2

- 函数参数传递 
    函数参数只能按值传递，因此传递引用类型时并非按引用访问，而是存储实参到变量对象中并与传进的变量引用内存中的同一个引用类型，因此将参数指向另一个引用类型时并不会影响到传进函数的变量所引用的值

- js执行机制 
    js逐行解释执行代码，当执行到函数调用时，此时调用函数内部的作用域链为Scope + 当前函数的AO对象
    但Scope保存的对象为调用此函数的AO/VO对象，仅为预编译保存的值 + 调用函数之前的代码执行值
    所以在调用函数之后才赋值的变量是取不到的，即使是闭包也如此(单线程执行代码即同步)

- 正则表达式 
    加标志g 会引起交替返回true 和false
    使用标志g 不会在匹配第一个项时就停止，而会保留状态，直到没有匹配才会重置
    可以写RegExp.lastIndex = 0重置这种状态

- ==比较操作符 
    参数数据类型相同直接进行比较
    + 不同 
        * 布尔值：转换为数值进行比较
        * 字符串：如果另一比较类型为数值会转化为数值通过Number()方法转换
        * 对象：先调用valueOf()比较，不行再调用toString()比较(得到基本类型)
    + 规则 
        * null和undefined不会转换且互相相等
        * NaN不等于任何值，即使是NaN
        * 两个对象会比较引用即指针

- stack(栈) 
    数据结构
    代码运行方式
    内存区域

- 异步/同步调用 
    异步的函数调用不返回原来代码调用处
    + 回调函数 
        * 需要带状态的才叫回调函数
        * 回调和闭包有一个共同的特性：在最终“回调”调用以前，前面所有的状态都得存着

- EventLoop 
    Event Loop是一个程序结构，用于等待和发送消息和事件
    EventLoop派一个人来轮询所有的，其他人都可以把观察条件和回调函数注册在EventLoop上，它进行统一的轮询，注册的人越多，轮询一圈的时间越长。但是简化了编程，不用每个人都写轮询了，提供API变得方便。

- 异步 => 回调 => EventLoop

