---
title: 你不知道的JavaScript
date: 2017-03-30 11:00:32
tags: 读书总结
---

## 简介
作者：[美]辛普森（Kyle Simpson）著
JavaScript系列书
适合中级前端工程师
看后收获颇大，个人是非常仰慕此书和作者的

### 状态
勉强看完第一卷，其余目前未看完，还未购买此书，之后会一起入手这一系列

## 正文

### 上卷
基本看完了一遍，后续会再刷的

#### 第一章
- 作用域
    + 编译原理
        * 分词/词法分析
        * 解析/语法分析
        * 代码生成
    + 理解作用域
        * 编译器
        * 引擎
            - LHS和RHS查找
        * 作用域
    + 作用域嵌套
    + 异常
- 词法作用域
    + 词法作用域 = 静态作用域
    + 动态作用域
        * 词法阶段
        * 欺骗语法
            - eval()
                + setTimeout()、setInterval()
                + new Function()
            - with()
- 函数作用域和块级作用域
    + 函数中的作用域
    + 隐藏内部实现
    + 函数作用域
        * 匿名和具名
        * 立即执行函数表达式(IIFE)
    + 块作用域
        * with
        * try/catch
        * let
        * const
- 提升
    + 先有声明后赋值
    + 函数优先
- 作用域闭包
    + 实质问题
        * 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行
        * 在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包
    + 循环和闭包
        * 每个迭代都被封闭在一个共享的全局作用域中
        * 利用IIFE为每个迭代都生成一个新的作用域
    + 模块

#### 第二章
- 关于this
    + this到底是什么
        this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用
- this全面解析
    + 调用位置
        从调用栈中分析出真正的调用位置的，它决定了this的绑定
    + 绑定规则
        * 默认绑定
        * 隐式绑定
            隐式丢失
        * 显式绑定（仍无法解决隐式丢失问题）
            - 硬绑定
                硬绑定之后就无法使用隐式绑定或者显式绑定来修改this
            - API调用的“上下文”
        * new绑定
    + 优先级
        * 是否在new中调用（new绑定）？
            如果是的话this绑定的是新创建的对象
        * 是否通过call、apply（显式绑定）或者硬绑定调用？
            如果是的话，this绑定的是指定的对象
        * 是否在某个上下文对象中调用（隐式绑定）？
            如果是的话，this绑定的是那个上下文对象
        * 都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象
    + 绑定例外
        * 被忽略的this
            - 传入null或undefined作为占位值this应用默认绑定规则
            - 更安全的this，Object.create(null)
        * 间接引用
            调用这个函数会应用默认绑定规则
        * 软绑定
        * this词法
- 对象
    + 语法
        两种形式定义
        * 声明形式
        * 构造形式
    + 类型
    + 内容
        * 可计算属性名
        * 属性与方法
        * 数组
            - 为数组添加命名属性，数组的length不改变
                若属性名是数字，那它会变成一个数值下标（会修改数组的内容而不添加属性）
        * 复制对象


*重构。。。*



### 中卷 
跳着看的，未曾看完

#### 类型与语法 

#### 异步与性能 
- 异步 
    + 事件循环
        * 队列
        ```
        var eventLoop = [];
        var event;

        while(true) {
            if(eventLoop.length > 0) {
                event = envenLoop.shift();
                try {
                    event();
                } catch(e) {
                    reportError(err);
                }
            }
        }
        ```
        * setTimeout() 在到时后才将回调函数放在事件循环中，永远不会调度到当前事件循环tick
    + Javascript 
        * 是单线程的使其函数中的代码执行具有原子性，即不中断完整运行
        * 减少了不确定性，相对多线程多进程只有事件顺序级别的
    + 并发 
        * 非交互
        * 交互 
            - 协调交互避免竞态
            - 措施 
                + 协调数序
                + 条件判断，加上锁
        * 协作 
            - 拆分自身，让其他并发有机会插入事件循环交替执行
    + 任务 
        * 挂在事件循环队列每次tick之后的一个队列
        * 会在当前事件循环末尾添加
        * 语句顺序 
            js引擎在编译完代码后会给这些js语句重新排序已提高执行速度
- 回调 
    + 代码抽象于生活，解释代码犹如思考的大脑
    + 开发者编写代码的时候是在计划一系列动作的发生，优秀的开发者会认真计划
    + 回调与我们大脑的顺序思维不匹配，以及控制反转带来的问题
    + 缺乏顺序性和可信任性    
- Promise 

